# ch07

---

Converted from PowerPoint presentation: `ch07.pptx`

---

Total slides: 31

---



---

<details>
<summary><strong>üìã Table of Contents</strong> (Click to expand)</summary>

## Table of Contents

1. [Slide 1: Introduction to Computing Using Python](#slide-1)
2. [Slide 2: The purpose of functions](#slide-2)
3. [Slide 3: Encapsulation through local variables](#slide-3)
4. [Slide 4: y](#slide-4)
5. [Slide 5: Function call namespace](#slide-5)
6. [Slide 6: Program stack](#slide-6)
7. [Slide 7: Scope and global vs. local namespace](#slide-7)
8. [Slide 8: scope.py](#slide-8)
9. [Slide 9: b](#slide-9)
10. [Slide 10: b](#slide-10)
11. [Slide 11: b](#slide-11)
12. [Slide 12: b](#slide-12)
13. [Slide 13: Introduction to Computing Using Python](#slide-13)
14. [Slide 14: Normal control flow](#slide-14)
15. [Slide 15: Introduction to Computing Using Python](#slide-15)
16. [Slide 16: Default behavior:](#slide-16)
17. [Slide 17: Format of a try/except statement pair](#slide-17)
18. [Slide 18: age.txt](#slide-18)
19. [Slide 19: Introduction to Computing Using Python](#slide-19)
20. [Slide 20: n = 2                      f(2)](#slide-20)
21. [Slide 21: Modules, revisited](#slide-21)
22. [Slide 22: Importing a module](#slide-22)
23. [Slide 23: The Python search path](#slide-23)
24. [Slide 24: name.py](#slide-24)
25. [Slide 25: name.txt](#slide-25)
26. [Slide 26: example.txt](#slide-26)
27. [Slide 27: example.txt](#slide-27)
28. [Slide 28: example.txt](#slide-28)
29. [Slide 29: __add__](#slide-29)
30. [Slide 30: __add__](#slide-30)
31. [Slide 31: lst.sort()](#slide-31)

</details>


---

<a id="slide-1"></a>

## Slide 1

Introduction to Computing Using Python

Namespaces and Exceptions, revisited

- Encapsulation in Functions
- Global versus Local Namespaces
- Exceptional Control Flow
- Modules as Namespaces
- Classes as Namespaces

---

<a id="slide-2"></a>

## Slide 2

Introduction to Computing Using Python

The purpose of functions

- Wrapping code into functions has several desirable goals:
  - Modularity: The complexity of developing a large program can be dealt with by breaking down the program into smaller, simpler, self-contained pieces. Each smaller piece (e.g., function) can be designed, implemented, tested, and debugged independently.
  - Code reuse: A fragment of code that is used multiple times in a program‚Äîor by multiple programs‚Äî should be packaged in a function. The program ends up being shorter, with a single function call replacing a code fragment, and clearer, because the name of the function can be more descriptive of the action being performed by the code fragment. Debugging also becomes easier because a bug in the code fragment will need to be fixed only once.
  - Encapsulation: A function hides its implementation details from the user of the function; removing the implementation details from the developer‚Äôs radar makes her job easier.

---

<a id="slide-3"></a>

## Slide 3

Introduction to Computing Using Python

Encapsulation through local variables

```python
x
# Output: Traceback (most recent call last):
```

- File "<pyshell#62>", line 1, in <module>
- x
- NameError: name 'x' is not defined
```python
y
# Output: Traceback (most recent call last):
```

- File "<pyshell#63>", line 1, in <module>
- y
- NameError: name 'y' is not defined

- def double(y):
- x=2
- print('x = {}, y = {}'.format(x,y))
- return x*y

Before executing function double(), variables x and y do not exist

- x and y exist only during the execution of function call double(5);
- they are said to be local variables of function double()

```python
x
# Output: Traceback (most recent call last):
```

- File "<pyshell#62>", line 1, in <module>
- x
- NameError: name 'x' is not defined
```python
y
# Output: Traceback (most recent call last):
```

- File "<pyshell#63>", line 1, in <module>
- y
- NameError: name 'y' is not defined
```python
res = double(5)
# Output: x = 2, y = 5
```

```python
x
# Output: Traceback (most recent call last):
```

- File "<pyshell#62>", line 1, in <module>
- x
- NameError: name 'x' is not defined
```python
y
# Output: Traceback (most recent call last):
```

- File "<pyshell#63>", line 1, in <module>
- y
- NameError: name 'y' is not defined
```python
res = double(5)
# Output: x = 2, y = 5
x
# Output: Traceback (most recent call last):
```

- File "<pyshell#66>", line 1, in <module>
- x
- NameError: name 'x' is not defined
```python
y
# Output: Traceback (most recent call last):
```

- File "<pyshell#67>", line 1, in <module>
- y
- NameError: name 'y' is not defined

After executing function double(), variables x and y still do not exist

Encapsulation makes modularity and code reuse possible

---

<a id="slide-4"></a>

## Slide 4

```python
x, y = 20, 50
```

Introduction to Computing Using Python

Function call namespace

- def double(y):
- x=2
- print('x = {}, y = {}'.format(x,y))
- return x*y

Even during the execution of double(), local variables x and y are invisible outside of the function!

```python
x
# Output: Traceback (most recent call last):
```

- File "<pyshell#62>", line 1, in <module>
- x
- NameError: name 'x' is not defined
```python
y
# Output: Traceback (most recent call last):
```

- File "<pyshell#63>", line 1, in <module>
- y
- NameError: name 'y' is not defined
```python
res = double(5)
# Output: x = 2, y = 5
x
# Output: Traceback (most recent call last):
```

- File "<pyshell#66>", line 1, in <module>
- x
- NameError: name 'x' is not defined
```python
y
# Output: Traceback (most recent call last):
```

- File "<pyshell#67>", line 1, in <module>
- y
- NameError: name 'y' is not defined

```python
x, y = 20, 50
res = double(5)
# Output: x = 2, y = 5
x, y
# Output: (20, 50)
```

y

5

Function call double(5)

x

2

```python
x, y = 20, 50
res = double(5)
```

- Every function call has a namespace
- in which local variables are stored

How is it possible that the values of x and y do not interfere with each other?

---

<a id="slide-5"></a>

## Slide 5

Introduction to Computing Using Python

Function call namespace

- def h(n):
- print('Start h')
- print(1/n)
- print(n)
- def g(n):
- print('Start g')
- h(n-1)
- print(n)
- def f(n):
- print('Start f')
- g(n-1)
- print(n)

```python
f(4)
```

```python
f(4)
# Output: Start f
```

```python
f(4)
# Output: Start f
```

- Start g

```python
f(4)
# Output: Start f
```

- Start g
- Start h

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5
- 2

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5
- 2
- 3

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5
- 2
- 3
- 4

- n = 4
- f(4)

- n = 3
- g(3)

- n = 2
- h(2)

- n = 4
- print('Start f')
- f(4)

- n = 4
- print('Start f')
- g(n-1)
- f(4)

- n = 4
- print('Start f')
- g(n-1)
- print(n)
- f(4)

- n = 3
- print('Start g')
- g(3)

- n = 3
- print('Start g')
- h(n-1)
- g(3)

- n = 3
- print('Start g')
- h(n-1)
- print(n)
- g(3)

- n = 2
- print('Start h')
- print(1/n)
- h(2)

- n = 2
- print('Start h')
- h(2)

- n = 2
- print('Start h')
- print(1/n)
- print(n)
- h(2)

- Every function call has a namespace
- in which local variables are stored

Note that there are several active values of n, one in each namespace; how are all the namespaces managed by Python?

How does Python know which line to return to?

---

<a id="slide-6"></a>

## Slide 6

Introduction to Computing Using Python

Program stack

- 1. def h(n):
- 2.     print('Start h')
- 3.     print(1/n)
- 4.     print(n)
- 5.
- 6. def g(n):
- 7.     print('Start g')
- 8.     h(n-1)
- 9.     print(n )
- 10.
- 11. def f(n):
- 12.     print('Start f')
- 13.     g(n-1)
- 14.     print(n)

```python
f(4)
```

```python
f(4)
# Output: Start f
```

```python
f(4)
# Output: Start f
```

- Start g

```python
f(4)
# Output: Start f
```

- Start g
- Start h

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5
- 2

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5
- 2
- 3

```python
f(4)
# Output: Start f
```

- Start g
- Start h
- 0.5
- 2
- 3
- 4

- n = 4
- f(4)

- n = 3
- g(3)

- n = 2
- h(2)

- n = 4
- print('Start f')
- f(4)

- n = 4
- print('Start f')
- g(n-1)
- f(4)

- n = 4
- print('Start f')
- g(n-1)
- print(n)
- f(4)

- n = 3
- print('Start g')
- g(3)

- n = 3
- print('Start g')
- h(n-1)
- g(3)

- n = 3
- print('Start g')
- h(n-1)
- print(n)
- g(3)

- n = 2
- print('Start h')
- print(1/n)
- h(2)

- n = 2
- print('Start h')
- h(2)

- n = 2
- print('Start h')
- print(1/n)
- print(n)
- h(2)


| line = 14 |
| --- |
| n = 4 |



| line = 9 |
| --- |
| n = 3 |


- The system dedicates
- a chunk of memory to
- the program stack;
- its job is to remember the values defined in a
- function call

Program stack

‚Ä¶ the statement to be executed after g(n-1) returns

- The system dedicates
- a chunk of memory to
- the program stack;
- its job is to remember the values defined in a
- function call and ‚Ä¶

---

<a id="slide-7"></a>

## Slide 7

Introduction to Computing Using Python

Scope and global vs. local namespace

- Every function call has a namespace associated with it.
  - This namespace is where names defined during the execution of the function (e.g., local variables) live.
  - The scope of these names (i.e., the space where they live) is the namespace of the function.

- In fact, every name in a Python program has a scope
  - Whether the name is of a variable, function, class, ‚Ä¶
  - Outside of its scope, the name does not exist, and any reference to it will result in an error.
  - Names assigned/defined in the interpreter shell or in a module and outside of any function are said to have global scope.

---

<a id="slide-8"></a>

## Slide 8

Introduction to Computing Using Python

Scope and global vs. local namespace

- In fact, every name in a Python program has a scope
  - Whether the name is of a variable, function, class, ‚Ä¶
  - Outside of its scope, the name does not exist, and any reference to it will result in an error.
  - Names assigned/defined in the interpreter shell or in a module and outside of any function are said to have global scope. Their scope is the namespace associated with the shell or the whole module. Variables with global scope are referred to as global variables.

x = 5

```python
x = 5
x
# Output: 5
```

scope.py

5

shell

x

- In fact, every name in a Python program has a scope
  - Whether the name is of a variable, function, class, ‚Ä¶
  - Outside of its scope, the name does not exist, and any reference to it will result in an error.
  - Names assigned/defined in the interpreter shell or in a module and outside of any function are said to have global scope. Their scope is the namespace associated with the shell

module scope

---

<a id="slide-9"></a>

## Slide 9

Introduction to Computing Using Python

Example: variable with local scope

b

Function call f(3)

```python
=== RESTART ====
```

- def f(b):       # f has global scope, b has local scope
- a = 6       # this a has scope local to function call f()
- return a*b  # this a is the local a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

a

shell

0

- def f(b):       # f has global scope, b has local scope
- a = 6       # this a has scope local to function call f()
- return a*b  # this a is the local a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

- def f(b):       # f has global scope, b has local scope
- a = 6       # this a has scope local to function call f()
- return a*b  # this a is the local a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

- def f(b):       # f has global scope, b has local scope
- a = 6       # this a has scope local to function call f()
- return a*b  # this a is the local a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

- def f(b):       # f has global scope, b has local scope
- a = 6       # this a has scope local to function call f()
- return a*b  # this a is the local a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

3

a

6

```python
=== RESTART ====
# Output: f(3) = 18
```

```python
=== RESTART ====
# Output: f(3) = 18
```

- a is 0

---

<a id="slide-10"></a>

## Slide 10

- def f(b):       # f has global scope, b has local scope
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

- def f(b):       # f has global scope, b has local scope
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

- def f(b):       # f has global scope, b has local scope
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

- def f(b):       # f has global scope, b has local scope
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

Introduction to Computing Using Python

Example: variable with global scope

b

Function call f(3)

```python
=== RESTART ====
```

- def f(b):       # f has global scope, b has local scope
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

a

shell

0

3

```python
=== RESTART ====
# Output: f(3) = 0
```

```python
=== RESTART ====
# Output: f(3) = 0
```

- a is 0

---

<a id="slide-11"></a>

## Slide 11

Introduction to Computing Using Python

How Python evaluates names

How does the Python interpreter decide whether to evaluate a name (of a variable, function, etc.) as a local or as a global name?

- Whenever the Python interpreter needs to evaluate a name, it searches for the name definition in this order:
  - First the enclosing function call namespace
  - Then the global (module) namespace
  - Finally the namespace of module builtins

b

Function call f(3)

3

a

global namespace

printf

module builtins

- def f(b):       # f has global scope, b has local scope
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a is still 0

0

f

f()

printf()

---

<a id="slide-12"></a>

## Slide 12

- def f(b):
- global a    # all references to a in f() are to the global a
- a = 6       # global a is changed
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a has been changed to 6

- def f(b):
- global a    # all references to a in f() are to the global a
- a = 6       # global a is changed
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a has been changed to 6

- def f(b):
- global a    # all references to a in f() are to the global a
- a = 6       # global a is changed
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a has been changed to 6

- def f(b):
- global a    # all references to a in f() are to the global a
- a = 6       # global a is changed
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a has been changed to 6

Introduction to Computing Using Python

Modifying a global variable inside a function

b

Function call f(3)

```python
=== RESTART ====
```

- def f(b):
- global a    # all references to a in f() are to the global a
- a = 6       # global a is changed
- return a*b  # this a is the global a
- a = 0           # this a has global scope
- print('f(3) = {}'.format(f(3)))
- print('a is {}'.format(a))        # global a has been changed to 6

a

shell

0

3

```python
=== RESTART ====
# Output: f(3) = 18
```

```python
=== RESTART ====
# Output: f(3) = 18
```

- a is 6

6

---

<a id="slide-13"></a>

## Slide 13

Introduction to Computing Using Python

Exceptions, revisited

  - The reason behind the term ‚Äúexception‚Äù is that when an error occurs and an exception object is created, the normal execution flow of the program is interrupted and execution switches to the exceptional control flow

- Recall that when the program execution gets into an erroneous state, an exception object is created
  - This object has a type that is related to the type of error
  - The object contains information about the error
  - The default behavior is to print this information and interrupt the execution of the statement that ‚Äúcaused‚Äù the error

---

<a id="slide-14"></a>

## Slide 14

Introduction to Computing Using Python

Exceptional control flow

```python
f(2)
```

```python
f(2)
# Output: Start f
```

```python
f(2)
# Output: Start f
```

- Start g

```python
f(2)
# Output: Start f
```

- Start g
- Start h

- n = 2
- f(2)

- n = 1
- g(1)

- n = 0
- h(0)

- n = 2
- print('Start f')
- f(2)

- n = 2
- print('Start f')
- g(n-1)
- f(2)

- n = 2
- print('Start f')
- g(n-1)
- print(n)
- f(2)

- n = 1
- print('Start g')
- g(1)

- n = 1
- print('Start g')
- h(n-1)
- g(1)

- n = 1
- print('Start g')
- h(n-1)
- print(n)
- g(1)

- n = 0
- print('Start h')
- print(1/n)
- h(0)

- n = 0
- print('Start h')
- h(0)

- n = 0
- print('Start h')
- print(1/n)
- print(n)
- h(0)

Normal control flow

  - The default behavior is to interrupt the execution of each ‚Äúactive‚Äù statement and print the error information contained in the exception object.

- 1. def h(n):
- 2.     print('Start h')
- 3.     print(1/n)
- 4.     print(n)
- 5.
- 6. def g(n):
- 7.     print('Start g')
- 8.     h(n-1)
- 9.     print(n )
- 10.
- 11. def f(n):
- 12.     print('Start f')
- 13.     g(n-1)
- 14.     print(n)

---

<a id="slide-15"></a>

## Slide 15

Introduction to Computing Using Python

Exceptional control flow

```python
f(2)
```

```python
f(2)
# Output: Start f
```

```python
f(2)
# Output: Start f
```

- Start g

```python
f(2)
# Output: Start f
```

- Start g
- Start h

```python
f(2)
# Output: Start f
```

- Start g
- Start h
- Traceback (most recent call last):
- File "<pyshell#79>", line 1, in <module>
- f(2)
- File "/Users/me/ch7/stack.py", line 13, in f
- g(n-1)
- File "/Users/me/ch7/stack.py", line 8, in g
- h(n-1)
- File "/Users/me/ch7/stack.py", line 3, in h
- print(1/n)
- ZeroDivisionError: division by zero

Exceptional control flow

  - The default behavior is to interrupt the execution of each ‚Äúactive‚Äù statement and print the error information contained in the exception object.

- 1. def h(n):
- 2.     print('Start h')
- 3.     print(1/n)
- 4.     print(n)
- 5.
- 6. def g(n):
- 7.     print('Start g')
- 8.     h(n-1)
- 9.     print(n )
- 10.
- 11. def f(n):
- 12.     print('Start f')
- 13.     g(n-1)
- 14.     print(n)

---

<a id="slide-16"></a>

## Slide 16

Introduction to Computing Using Python

Catching and handling exceptions

It is possible to override the default behavior (print error information and ‚Äúcrash‚Äù) when an exception is raised, using try/except statements

- strAge = input('Enter your age: ')
- intAge = int(strAge)
- print('You are {} years old.'.format(intAge))

- try:
- strAge = input('Enter your age: ')
- intAge = int(strAge)
- print('You are {} years old.'.format(intAge))
- except:
- print('Enter your age using digits 0-9!')

```python
======================== RESTART ========================
# Output: Enter your age: fifteen
# Output: Traceback (most recent call last):
```

- File "/Users/me/age1.py", line 2, in <module>
- intAge = int(strAge)
- ValueError: invalid literal for int() with base 10: 'fifteen'

```python
========== RESTART ==========
# Output: Enter your age: fifteen
```

- Enter your age using digits 0-9!

Default behavior:

If an exception is raised while executing the try block, then the block of the associated except statement is executed

The except code block is the exception handler

---

<a id="slide-17"></a>

## Slide 17

Introduction to Computing Using Python

Format of a try/except statement pair

- try:
- <indented code block>
- except:
- <exception handler block>
- <non-indented statement>

The format of a try/except pair of statements is:

- The exception handler handles any exception raised in the try block
- The except statement is said to catch the (raised) exception

- It is possible to restrict the except statement to catch exceptions of
- a specific type only

- try:
- <indented code block>
- except <ExceptionType>:
- <exception handler block>
- <non-indented statement>

---

<a id="slide-18"></a>

## Slide 18

```python
readAge('age.txt')
# Output: Value cannot be converted to integer.
```

Introduction to Computing Using Python

Format of a try/except statement pair

- It is possible to restrict the except statement to catch exceptions of
- a specific type only

- def readAge(filename):
- 'converts first line of file filename to an integer and prints it'
- try:
- infile = open(filename)
- strAge = infile.readline()
- age = int(strAge)
- print('age is', age)
- except ValueError:
- print('Value cannot be converted to integer.')

1 fifteen

age.txt

```python
readAge('age.txt')
# Output: Value cannot be converted to integer.
readAge('age.text')
# Output: Traceback (most recent call last):
```

- File "<pyshell#11>", line 1, in <module>
- readAge('age.text')
- File "/Users/me/ch7.py", line 12, in readAge
- infile = open(filename)
- IOError: [Errno 2] No such file or directory: 'age.text'

default exception handler prints this

---

<a id="slide-19"></a>

## Slide 19

Introduction to Computing Using Python

Multiple exception handlers

- It is possible to restrict the except statement to catch exceptions of
- a specific type only

- def readAge(filename):
- 'converts first line of file filename to an integer and prints it'
- try:
- infile = open(filename)
- strAge = infile.readline()
- age = int(strAge)
- print('age is',age)
- except IOError:
- # executed only if an IOError exception is raised
- print('Input/Output error.')
- except ValueError:
- # executed only if a ValueError exception is raised
- print('Value cannot be converted to integer.')
- except:
- # executed if an exception other than IOError or ValueError is raised
- print('Other error.')

---

<a id="slide-20"></a>

## Slide 20

Introduction to Computing Using Python

Controlling the exceptional control flow

```python
try:
# Output: f(2)
```

- except:
- print('!!')

```python
try:
# Output: f(2)
```

- except:
- print('!!')
- Start f

```python
try:
# Output: f(2)
```

- except:
- print('!!')
- Start f
- Start g

```python
try:
# Output: f(2)
```

- except:
- print('!!')
- Start f
- Start g
- Start h

- n = 2
- f(2)

- n = 1
- g(1)

- n = 0
- h(0)

- n = 2
- print('Start f')
- f(2)

- n = 2
- print('Start f')
- g(n-1)
- f(2)

- n = 2
- print('Start f')
- g(n-1)
- print(n)
- f(2)

- n = 1
- print('Start g')
- g(1)

- n = 1
- print('Start g')
- h(n-1)
- g(1)

- n = 1
- print('Start g')
- h(n-1)
- print(n)
- g(1)

- n = 0
- print('Start h')
- print(1/n)
- h(0)

- n = 0
- print('Start h')
- h(0)

- n = 0
- print('Start h')
- print(1/n)
- print(n)
- h(0)

- 1. def h(n):
- 2.     print('Start h')
- 3.     print(1/n)
- 4.     print(n)
- 5.
- 6. def g(n):
- 7.     print('Start g')
- 8.     h(n-1)
- 9.     print(n )
- 10.
- 11. def f(n):
- 12.     print('Start f')
- 13.     g(n-1)
- 14.     print(n)

```python
try:
# Output: f(2)
```

- except:
- print('!!')
- Start f
- Start g
- Start h
- !!

---

<a id="slide-21"></a>

## Slide 21

```python
import math
dir(math)
math.sqrt
# Output: <built-in function sqrt>
math.pi
# Output: 3.141592653589793
```

Introduction to Computing Using Python

Modules, revisited

- When the module is executed (imported), then the module is (also) a namespace.

A module is a file containing Python code.

- When the module is executed (imported), then the module is (also) a namespace.
  - This namespace has a name, typically the name of the module.

- When the module is executed (imported), then the module is (also) a namespace.
  - This namespace has a name, typically the name of the module.
  - In this namespace live the names that are defined in the global scope of the module: the names of functions, values, and classes defined in the module.
  - These names are the module‚Äôs attributes.

- When the module is executed (imported), then the module is (also) a namespace.
  - This namespace has a name, typically the name of the module.
  - In this namespace live the names that are defined in the global scope of the module: the names of functions, values, and classes defined in the module.

Built-in function dir() returns the names defined in a namespace

To access the imported module‚Äôs attributes, the name of the namespace must be specified

---

<a id="slide-22"></a>

## Slide 22

Introduction to Computing Using Python

Importing a module

- When the Python interpreter executes an import statement, it:
  - Looks for the file corresponding to the module to be imported.
  - Runs the module‚Äôs code to create the objects defined in the module.
  - Creates a namespace where the names of these objects will live.

- An import statement only lists a name, the name of the module
  - without any directory information or .py suffix.
- Python uses the Python search path to locate the module.
  - The search path is a list of directories where Python looks for modules.
  - The variable name path defined in the Standard Library module sys refers to this list.

- When the Python interpreter executes an import statement, it:
  - Looks for the file corresponding to the module to be imported.

```python
import sys
sys.path
# Output: ['/Users/me', '/Library/Frameworks/Python.framework/Versions/3.2/lib/python32.zip',
```

- . . .
- '/Library/Frameworks/Python.framework/Versions/3.2/lib/python3.2/site-packages']

current working directory

Standard Library folders

---

<a id="slide-23"></a>

## Slide 23

```python
================ RESTART ================
dir()
# Output: ['__builtins__', '__doc__', '__name__', '__package__']
import example
# Output: Traceback (most recent call last):
```

- File "<pyshell#79>", line 1, in <module>
- import example
- ImportError: No module named example

```python
================ RESTART ================
dir()
# Output: ['__builtins__', '__doc__', '__name__', '__package__']
```

Introduction to Computing Using Python

The Python search path

  - Suppose we want to import module example stored in folder /Users/me that is not in list sys.path

```python
================ RESTART ================
```

```python
================ RESTART ================
dir()
# Output: ['__builtins__', '__doc__', '__name__', '__package__']
import example
# Output: Traceback (most recent call last):
```

- File "<pyshell#79>", line 1, in <module>
- import example
- ImportError: No module named example
```python
import sys
sys.path.append('/Users/me')
import example
example.f
# Output: <function f at 0x10278dc88>
example.x
# Output: 0
```

```python
================ RESTART ================
dir()
# Output: ['__builtins__', '__doc__', '__name__', '__package__']
import example
# Output: Traceback (most recent call last):
```

- File "<pyshell#79>", line 1, in <module>
- import example
- ImportError: No module named example
```python
import sys
sys.path.append('/Users/me')
import example
example.f
# Output: <function f at 0x10278dc88>
example.x
# Output: 0
dir()
# Output: ['__builtins__', '__doc__', '__name__', '__package__', 'example', 'sys‚Äô]
```

  - By just adding folder /Users/me to the search path, module example can be imported

- When called without an argument, function dir() returns the names in the top-level module
  - the shell, in this case.

- 'an example module'
- def f():
- 'function f'
- print('Executing f()')
- def g():
- 'function g'
- print('Executing g()')
- x = 0  # global var

names in the shell namespace; note that example is not in

no folder in the Python search path contains module example

---

<a id="slide-24"></a>

## Slide 24

Introduction to Computing Using Python

Top-level module

  - A computer application is a program typically split across multiple modules.
  - One of the modules is special: It contains the ‚Äúmain program‚Äù. This module is referred to as the top-level module.
    - The remaining modules are ‚Äúlibrary‚Äù modules that are imported by other modules and that contain functions and classes used by it

```python
=== RESTART ===
# Output: My name is __main__
```

print('My name is {}'.format(__name__))

name.py

- A module is a top-level module if:
  - it is run from the shell
  - it is run at the command line

- > python name.py
- My name is __main__

  - A computer application is a program typically split across multiple modules.
  - One of the modules is special: It contains the ‚Äúmain program‚Äù. This module is referred to as the top-level module.
    - The remaining modules are ‚Äúlibrary‚Äù modules that are imported by other modules and that contain functions and classes used by it
  - When a module is imported, Python creates a few ‚Äúbookkeeping‚Äù variables in the module namespace, including variable __name__:
    - set to '__main__', if the module is being run as a top-level module

- A module is a top-level module if:
  - it is run from the shell
  - it is run at the command line

- A module is a top-level module if:
  - it is run from the shell
  - it is run at the command line

---

<a id="slide-25"></a>

## Slide 25

Introduction to Computing Using Python

Top-level module

```python
import name
# Output: My name is name
```

print('My name is {}'.format(__name__))

name.txt

  - A computer application is a program typically split across multiple modules.
  - One of the modules is special: It contains the ‚Äúmain program‚Äù. This module is referred to as the top-level module.
    - The remaining modules are ‚Äúlibrary‚Äù modules that are imported by the top-level module and that contain functions and classes used by it
  - When a module is imported, Python creates a few ‚Äúbookkeeping‚Äù variables in the module namespace, including variable __name__:
    - set to '__main__', if the module is being run as a top-level module
    - set to the module‚Äôs name, if the file is being imported by another module

import name

import.txt

```python
=== RESTART ===
# Output: My name is name
```

---

<a id="slide-26"></a>

## Slide 26

Introduction to Computing Using Python

Three ways to import module attributes

- 'an example module'
- def f():
- 'function f'
- print('Executing f()')
- def g():
- 'function g'
- print('Executing g()')
- x = 0  # global var

example.txt

namespace __main__

f

module example

example

f()

0

g

x

g()

1.  Import the (name of the) module

```python
import example
```

```python
import example
example.x
# Output: 0
example.f
# Output: <function f at 0x10278dd98>
example.f()
# Output: Executing f()
```

---

<a id="slide-27"></a>

## Slide 27

Introduction to Computing Using Python

Three ways to import module attributes

- 'an example module'
- def f():
- 'function f'
- print('Executing f()')
- def g():
- 'function g'
- print('Executing g()')
- x = 0  # global var

example.txt

namespace __main__

f

module example

f

f()

0

g

x

g()

2.  Import specific module attributes

```python
from example import f
```

```python
from example import f
f()
# Output: Executing f()
x
# Output: Traceback (most recent call last):
```

- File "<pyshell#28>", line 1, in <module>
- x
- NameError: name 'x' is not defined

---

<a id="slide-28"></a>

## Slide 28

Introduction to Computing Using Python

Three ways to import module attributes

- 'an example module'
- def f():
- 'function f'
- print('Executing f()')
- def g():
- 'function g'
- print('Executing g()')
- x = 0  # global var

example.txt

namespace __main__

3.  Import all module attributes

```python
from example import *
```

```python
from example import *
f()
# Output: Executing f()
g()
# Output: Executing g()
x
# Output: 0
```

f

module example

f

f()

0

g

x

g()

g

x

---

<a id="slide-29"></a>

## Slide 29

Introduction to Computing Using Python

A class is a namespace

```python
list.pop
# Output: <method 'pop' of 'list' objects>
list.sort
# Output: <method 'sort' of 'list' objects>
```

__add__

namespace list

__add__()

sort()

count

x

count()

pop

pop()

- A class is really a namespace
  - The name of this namespace is the name of the class
  - The names defined in  this namespace are the class attributes (e.g., class methods)

. . .

- A class is really a namespace
  - The name of this namespace is the name of the class
  - The names defined in  this namespace are the class attributes (e.g., class methods)
  - The class attributes can be accessed using the standard namespace notation

- Function dir() can be used to list
- the class attributes

```python
list.pop
# Output: <method 'pop' of 'list' objects>
list.sort
# Output: <method 'sort' of 'list' objects>
dir(list)
# Output: ['__add__', '__class__',
```

- ...
- 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

---

<a id="slide-30"></a>

## Slide 30

- A class method is really a function defined in the class namespace; when Python executes
- it first translates it to
- and actually executes this last statement

Introduction to Computing Using Python

Class methods

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
```

__add__

namespace list

__add__()

sort()

count

x

count()

pop

pop()

. . .

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
list.sort(lst)
lst
# Output: [1, 2, 3, 7, 8, 9]
```

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
list.sort(lst)
lst
# Output: [1, 2, 3, 7, 8, 9]
lst.append(6)
lst
# Output: [1, 2, 3, 7, 8, 9, 6]
```

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
list.sort(lst)
lst
# Output: [1, 2, 3, 7, 8, 9]
lst.append(6)
lst
# Output: [1, 2, 3, 7, 8, 9, 6]
list.append(lst, 5)
lst
# Output: [1, 2, 3, 7, 8, 9, 6, 5]
```

lst.sort()

list.sort(lst)

lst.append(6)

instance.method(arg1, arg2, ‚Ä¶)

list.append(lst, 6)

class.method(instance, arg1, arg2, ‚Ä¶)

- The function has
- an extra argument,
- which is the object
- invoking the method

---

<a id="slide-31"></a>

## Slide 31

- Rewrite the below Python statement so that instead of making the usual method invocations
- you use the notation

Introduction to Computing Using Python

Exercise

```python
s = 'hello'
s = 'ACM'
s.lower()
# Output: 'acm'
s.find('C')
# Output: 1
s.replace('AC', 'IB')
# Output: 'IBM'
```

lst.sort()

list.sort(lst)

lst.append(6)

instance.method(arg1, arg2, ‚Ä¶)

list.append(lst, 6)

class.method(instance, arg1, arg2, ‚Ä¶)

```python
s = 'ACM'
str.lower(s)
# Output: 'acm'
str.find(s, 'C')
# Output: 1
str.replace(s, 'AC', 'IB')
# Output: 'IBM'
```