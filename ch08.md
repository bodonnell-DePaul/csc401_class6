# ch08

---

Converted from PowerPoint presentation: `ch08.pptx`

---

Total slides: 53

---



---

<details>
<summary><strong>📋 Table of Contents</strong> (Click to expand)</summary>

## Table of Contents

1. [Slide 1: Object-Oriented Programming](#slide-1)
2. [Slide 2: x](#slide-2)
3. [Slide 3: __add__](#slide-3)
4. [Slide 4: __add__](#slide-4)
5. [Slide 5: setx](#slide-5)
6. [Slide 6: Defining the class Point](#slide-6)
7. [Slide 7: Defining the class Point](#slide-7)
8. [Slide 8: x](#slide-8)
9. [Slide 9: Defining the class Point](#slide-9)
10. [Slide 10: Exercise](#slide-10)
11. [Slide 11: The instance namespaces](#slide-11)
12. [Slide 12: instance attributes of a](#slide-12)
13. [Slide 13: The class and instance attributes](#slide-13)
14. [Slide 14: Note: no documentation](#slide-14)
15. [Slide 15: (No) class documentation](#slide-15)
16. [Slide 16: Class documentation](#slide-16)
17. [Slide 17: Class documentation](#slide-17)
18. [Slide 18: Exercise](#slide-18)
19. [Slide 19: Overloaded constructor](#slide-19)
20. [Slide 20: Default constructor](#slide-20)
21. [Slide 21: Exercise](#slide-21)
22. [Slide 22: Example: class Card](#slide-22)
23. [Slide 23: Container class: class Deck](#slide-23)
24. [Slide 24: Container class: class Deck](#slide-24)
25. [Slide 25: Container class: class Queue](#slide-25)
26. [Slide 26: rear](#slide-26)
27. [Slide 27: Container class: class Queue](#slide-27)
28. [Slide 28: What would we prefer?](#slide-28)
29. [Slide 29: object1.__add__(object2)](#slide-29)
30. [Slide 30: Python operators](#slide-30)
31. [Slide 31: Overloading repr()](#slide-31)
32. [Slide 32: Overloading operator +](#slide-32)
33. [Slide 33: Overloading operator len()](#slide-33)
34. [Slide 34: Exercise](#slide-34)
35. [Slide 35: str() vs repr()](#slide-35)
36. [Slide 36: str() vs repr()](#slide-36)
37. [Slide 37: ✗](#slide-37)
38. [Slide 38: Overloading operator ==](#slide-38)
39. [Slide 39: Exercise](#slide-39)
40. [Slide 40: Inheritance](#slide-40)
41. [Slide 41: Implementing class MyList](#slide-41)
42. [Slide 42: Implementing class MyList](#slide-42)
43. [Slide 43: choice](#slide-43)
44. [Slide 44: class <Class Name>:](#slide-44)
45. [Slide 45: Overriding superclass methods](#slide-45)
46. [Slide 46: Overriding superclass methods](#slide-46)
47. [Slide 47: Extending superclass methods](#slide-47)
48. [Slide 48: Object-Oriented Programming (OOP)](#slide-48)
49. [Slide 49: An encapsulation issue](#slide-49)
50. [Slide 50: Introduction to Computing Using Python](#slide-50)
51. [Slide 51: Introduction to Computing Using Python](#slide-51)
52. [Slide 52: Class Queue, revisited](#slide-52)
53. [Slide 53: Class Queue, revisited](#slide-53)

</details>


---

<a id="slide-1"></a>

## Slide 1

Introduction to Computing Using Python

Object-Oriented Programming

- Defining new Python Classes
- Container Classes
- Overloaded Operators
- Inheritance
- User-Defined Exceptions

---

<a id="slide-2"></a>

## Slide 2

Introduction to Computing Using Python

A new class: Point

```python
point = Point()
```

- Suppose we would like to have a class that represents points on a plane
  - for a graphics app, say

x

y

point

Let’s first informally describe how we would like to use this class

```python
point = Point()
point.setx(3)
```

```python
point = Point()
point.setx(3)
point.sety(4)
```

```python
point = Point()
point.setx(3)
point.sety(4)
point.get()
# Output: (3, 4)
```

```python
point = Point()
point.setx(3)
point.sety(4)
point.get()
# Output: (3, 4)
point.move(1, 2)
```

```python
point = Point()
point.setx(3)
point.sety(4)
point.get()
# Output: (3, 4)
point.move(1, 2)
point.get()
# Output: (4, 6)
```

```python
point = Point()
point.setx(3)
point.sety(4)
point.get()
# Output: (3, 4)
point.move(1, 2)
point.get()
# Output: (4, 6)
point.setx(-1)
```

```python
point = Point()
point.setx(3)
point.sety(4)
point.get()
# Output: (3, 4)
point.move(1, 2)
point.get()
# Output: (4, 6)
point.setx(-1)
point.get()
# Output: (-1, 6)
```


| Usage | Explanation |
| --- | --- |
| p.setx(xcoord) | Sets the x coordinate of point p to xcoord |
| p.sety(ycoord) | Sets the y coordinate of point p to ycoord |
| p.get() | Returns the x and y coordinates of point p as a tuple (x, y) |
| p.move(dx, dy) | Changes the coordinates of point p from the current (x, y) to (x+dx, y+dy) |


How do we create this new class Point?

---

<a id="slide-3"></a>

## Slide 3

Introduction to Computing Using Python

A class is a namespace (REVIEW)

```python
list.pop
# Output: <method 'pop' of 'list' objects>
list.sort
# Output: <method 'sort' of 'list' objects>
```

__add__

namespace list

__add__()

sort()

count

x

count()

pop

pop()

- A class is really a namespace
  - The name of this namespace is the name of the class
  - The names defined in  this namespace are the class attributes (e.g., class methods)

. . .

- A class is really a namespace
  - The name of this namespace is the name of the class
  - The names defined in  this namespace are the class attributes (e.g., class methods)
  - The class attributes can be accessed using the standard namespace notation

- Function dir() can be used to list
- the class attributes

```python
list.pop
# Output: <method 'pop' of 'list' objects>
list.sort
# Output: <method 'sort' of 'list' objects>
dir(list)
# Output: ['__add__', '__class__',
```

- ...
- 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

---

<a id="slide-4"></a>

## Slide 4

- A class method is really a function defined in the class namespace; when Python executes
- it first translates it to
- and actually executes this last statement

Introduction to Computing Using Python

Class methods (REVIEW)

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
```

__add__

namespace list

__add__()

sort()

count

x

count()

pop

pop()

. . .

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
list.sort(lst)
lst
# Output: [1, 2, 3, 7, 8, 9]
```

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
list.sort(lst)
lst
# Output: [1, 2, 3, 7, 8, 9]
lst.append(6)
lst
# Output: [1, 2, 3, 7, 8, 9, 6]
```

```python
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
lst.sort()
lst
# Output: [1, 2, 3, 7, 8, 9]
lst = [9, 1, 8, 2, 7, 3]
lst
# Output: [9, 1, 8, 2, 7, 3]
list.sort(lst)
lst
# Output: [1, 2, 3, 7, 8, 9]
lst.append(6)
lst
# Output: [1, 2, 3, 7, 8, 9, 6]
list.append(lst, 5)
lst
# Output: [1, 2, 3, 7, 8, 9, 6, 5]
```

lst.sort()

list.sort(lst)

lst.append(6)

instance.method(arg1, arg2, …)

list.append(lst, 6)

class.method(instance, arg1, arg2, …)

- The function has
- an extra argument,
- which is the object
- invoking the method

---

<a id="slide-5"></a>

## Slide 5


| Usage | Explanation |
| --- | --- |
| p.setx(xcoord) | Sets the x coordinate of point p to xcoord |
| p.sety(ycoord) | Sets the y coordinate of point p to ycoord |
| p.get() | Returns the x and y coordinates of point p as a tuple (x, y) |
| p.move(dx, dy) | Changes the coordinates of point p from the current (x, y) to (x+dx, y+dy) |


Introduction to Computing Using Python

Developing the class Point

setx

namespace Point

setx()

move()

sety

move

sety()

get

get()

- A namespace called Point needs to be defined
- Namespace Point will store the names of the 4 methods (the class
- attributes)

. . .

---

<a id="slide-6"></a>

## Slide 6

Introduction to Computing Using Python

Defining the class Point

- A namespace called Point needs to be defined
- Namespace Point will store the names of the 4 methods (the class
- attributes)


| Usage | Explanation |
| --- | --- |
| p.setx(xcoord) | Sets the x coordinate of point p to xcoord |
| p.sety(ycoord) | Sets the y coordinate of point p to ycoord |
| p.get() | Returns the x and y coordinates of point p as a tuple (x, y) |
| p.move(dx, dy) | Changes the coordinates of point p from the current (x, y) to (x+dx, y+dy) |



| Usage | Explanation |
| --- | --- |
| setx(p, xcoord) | Sets the x coordinate of point p to xcoord |
| sety(p, ycoord) | Sets the y coordinate of point p to ycoord |
| get(p) | Returns the x and y coordinates of point p as a tuple (x, y) |
| move(p, dx, dy) | Changes the coordinates of point p from the current (x, y) to (x+dx, y+dy) |


- Each method is a function that has an extra (first) argument
- which refers to the object that the method is invoked on

```python
Point.get(point)
# Output: (-1, 6)
Point.setx(point, 0)
Point.get(point)
# Output: (0, 6)
Point.sety(point, 0)
Point.get(point)
# Output: (0, 0)
Point.move(point, 2, -2)
Point.get(point)
# Output: (2, -2)
```

---

<a id="slide-7"></a>

## Slide 7

Introduction to Computing Using Python

Defining the class Point

- A namespace called Point needs to be defined
- Namespace Point will store the names of the 4 methods (the class
- attributes)

- Each method is a function that has an extra (first) argument
- which refers to the object that the method is invoked on

- class Point:
- 'class that represents a point in the plane'
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- # to be implemented
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- # to be implemented
- def get(self):
- 'return coordinates of the point as a tuple'
- # to be implemented
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- # to be implemented

The Python class statement defines a new class (and associated namespace)

- variable that refers to the object
- on which the method is invoked

---

<a id="slide-8"></a>

## Slide 8

Introduction to Computing Using Python

The object namespace

We know that a namespace is associated with every class

A namespace is also associated with every object

- class Point:
- 'class that represents a point in the plane'
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- # to be implemented
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- # to be implemented
- def get(self):
- 'return coordinates of the point as a tuple'
- # to be implemented
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- # to be implemented

The Python class statement defines a new class

```python
point = Point()
```

x

namespace point

3

```python
point = Point()
point.x = 3
```

```python
point = Point()
```

```python
point = Point()
Point.setx(point, 3)
```

- class Point:
- 'class that represents a point in the plane'
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- # to be implemented
- def get(self):
- 'return coordinates of the point as a tuple'
- # to be implemented
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- # to be implemented

---

<a id="slide-9"></a>

## Slide 9

Introduction to Computing Using Python

Defining the class Point

- A namespace called Point needs to be defined
- Namespace Point will store the names of the 4 methods (the class attributes)

- Each method is a function that has an extra (first) argument
- which refers to the object that the method is invoked on

- class Point:
- 'class that represents a point in the plane'
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy

---

<a id="slide-10"></a>

## Slide 10

Introduction to Computing Using Python

Exercise

Add new method getx() to class Point

- class Point:
- 'class that represents a point in the plane'
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy

```python
point = Point()
point.setx(3)
point.getx()
# Output: 3
```

- class Point:
- 'class that represents a point in the plane'
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy
- def getx(self):
- 'return x coordinate of the point'
- return self.x

---

<a id="slide-11"></a>

## Slide 11

Introduction to Computing Using Python

The instance namespaces

- Variables stored in the namespace of an object (instance) are called instance variables (or instance attributes)
- Every object will have its own namespace and therefore its own instance variables

x

object a

3

y

4

x

object b

0

y

0

```python
a = Point()
a.setx(3)
a.sety(4)
```

```python
a = Point()
a.setx(3)
a.sety(4)
b = Point()
b.setx(0)
b.sety(0)
```

```python
a = Point()
a.setx(3)
a.sety(4)
b = Point()
b.setx(0)
b.sety(0)
a.get()
# Output: (3, 4)
b.get()
# Output: (0, 0)
```

```python
a = Point()
a.setx(3)
a.sety(4)
b = Point()
b.setx(0)
b.sety(0)
a.get()
# Output: (3, 4)
b.get()
# Output: (0, 0)
a.x
# Output: 3
b.x
# Output: 0
```

---

<a id="slide-12"></a>

## Slide 12

Introduction to Computing Using Python

The class and instance attributes

x

object a

3

y

4

x

object b

0

y

0

```python
dir(a)
```

An instance of a class inherits all the class attributes

setx

namespace Point

sety

move

get

. . .

. . .

class Point attributes inherited by a

Function dir() returns the attributes of an object, including the inherited ones

instance attributes of a

---

<a id="slide-13"></a>

## Slide 13

Introduction to Computing Using Python

The class and instance attributes

x

object a

3

y

4

x

object b

0

y

0

setx

namespace Point

sety

move

get

. . .

. . .

- Method names setx, sety, get, and move are defined in namespace Point
  - not in namespace a or b.

- Python does the following when evaluating expression a.setx:
  - It first attempts to find name setx in object (namespace) a.
  - If name setx does not exist in namespace a, then it attempts to find setx in namespace Point

---

<a id="slide-14"></a>

## Slide 14

Introduction to Computing Using Python

Class definition, in general

- class <Class Name>:
- <class variable 1> = <value>
- <class variable 2> = <value>
- ...
- def <class method 1>(self, arg11, arg12, ...):
- <implementation of class method 1>
- def <class method 2>(self, arg21, arg22, ...):
- <implementation of class method 2>
- ...

- class Point:
- def setx(self, xcoord):
- self.x = xcoord
- def sety(self, ycoord):
- self.y = ycoord
- def get(self):
- return (self.x, self.y)
- def move(self, dx, dy):
- self.x += dx
- self.y += dy

Note: no documentation

---

<a id="slide-15"></a>

## Slide 15

Introduction to Computing Using Python

(No) class documentation

```python
help(Point)
# Output: Help on class Point in module __main__:
```

- class Point(builtins.object)
- |  Methods defined here:
- |
- |  get(self)
- |
- |  move(self, dx, dy)
- |
- |  setx(self, xcoord)
- |
- |  sety(self, ycoord)
- |
- |  ----------------------------------------------------------------------
- |  Data descriptors defined here:
- |
- |  __dict__
- |      dictionary for instance variables (if defined)
- |
- |  __weakref__
- |      list of weak references to the object (if defined)

---

<a id="slide-16"></a>

## Slide 16

Introduction to Computing Using Python

Class documentation

- class Point:
- 'class that represents a point in the plane'
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy

---

<a id="slide-17"></a>

## Slide 17

Introduction to Computing Using Python

Class documentation

```python
help(Point)
# Output: Help on class Point in module __main__:
```

- class Point(builtins.object)
- |  class that represents a point in the plane
- |
- |  Methods defined here:
- |
- |  get(self)
- |      return a tuple with x and y coordinates of the point
- |
- |  move(self, dx, dy)
- |      change the x and y coordinates by dx and dy
- |
- |  setx(self, xcoord)
- |      set x coordinate of point to xcoord
- |
- |  sety(self, ycoord)
- |      set y coordinate of point to ycoord
- |
- |  ----------------------------------------------------------------------
- |  Data descriptors defined here:
- ...

---

<a id="slide-18"></a>

## Slide 18

Introduction to Computing Using Python

Exercise

- Develop class Animal that supports methods:
  - setSpecies(species)
  - setLanguage(language)
  - speak()

```python
snoopy = Animal()
snoopy.setpecies('dog')
snoopy.setLanguage('bark')
snoopy.speak()
# Output: I am a dog and I bark.
```

- class Animal:
- 'represents an animal'
- def setSpecies(self, species):
- 'sets the animal species'
- self.spec = species
- def setLanguage(self, language):
- 'sets the animal language'
- self.lang = language
- def speak(self):
- 'prints a sentence by the animal'
- print('I am a {} and I {}.'.format(self.spec, self.lang))

---

<a id="slide-19"></a>

## Slide 19

```python
a = Point()
a.setx(3)
a.sety(4)
a.get()
# Output: (3, 4)
```

Introduction to Computing Using Python

Overloaded constructor

It would be better if we could do it in one step

```python
a = Point(3, 4)
a.get()
# Output: (3, 4)
```

- class Point:
- 'class that represents a point in the plane’
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy

- class Point:
- 'class that represents a point in the plane’
- def __init__(self, xcoord, ycoord):
- 'initialize coordinates to (xcoord, ycoord)'
- self.x = xcoord
- self.y = ycoord
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy

It takes 3 steps to create a Point object at specific x and y coordinates

called by Python each time a Point object is created

---

<a id="slide-20"></a>

## Slide 20

Introduction to Computing Using Python

Default constructor

- class Point:
- 'class that represents a point in the plane’
- def __init__(self, xcoord, ycoord):
- 'initialize coordinates to (xcoord, ycoord)'
- self.x = xcoord
- self.y = ycoord
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy

Problem: Now we can’t create an uninitialized point

```python
a = Point()
# Output: Traceback (most recent call last):
```

- File "<pyshell#0>", line 1, in <module>
- a = Point()
- TypeError: __init__() takes exactly 3 arguments (1 given)

```python
n = int(3)
n
# Output: 3
n = int()
n
# Output: 0
```

Built-in types support default constructors

- class Point:
- 'class that represents a point in the plane’
- def __init__(self, xcoord=0, ycoord=0):
- 'initialize coordinates to (xcoord, ycoord)'
- self.x = xcoord
- self.y = ycoord
- def setx(self, xcoord):
- 'set x coordinate of point to xcoord'
- self.x = xcoord
- def sety(self, ycoord):
- 'set y coordinate of point to ycoord'
- self.y = ycoord
- def get(self):
- 'return coordinates of the point as a tuple'
- return (self.x, self.y)
- def move(self, dx, dy):
- 'change the x and y coordinates by dx and dy'
- self.x += dx
- self.y += dy

```python
a = Point()
a.get()
# Output: (0, 0)
```

Want to augment class Point so it supports a default constructor

xcoord is set to 0 if the argument is missing

ycoord is set to 0 if the argument is missing

---

<a id="slide-21"></a>

## Slide 21

Introduction to Computing Using Python

Exercise

Modify the class Animal we developed in the previous section so it supports a two, one, or no input argument constructor

```python
snoopy = Animal('dog', 'bark')
snoopy.speak()
# Output: I am a dog and I bark.
tweety = Animal('canary')
tweety.speak()
# Output: I am a canary and I make sounds.
animal = Animal()
animal.speak()
# Output: I am a animal and I make sounds.
```

- class Animal:
- 'represents an animal'
- def __init__(self, species='animal', language='make sounds'):
- self.species = species
- self.language = language
- def setSpecies(self, species):
- 'sets the animal species'
- self.spec = species
- def setLanguage(self, language):
- 'sets the animal language'
- self.lang = language
- def speak(self):
- 'prints a sentence by the animal'
- print('I am a {} and I {}.'.format(self.spec, self.lang))

---

<a id="slide-22"></a>

## Slide 22

Introduction to Computing Using Python

Example: class Card

Goal: develop a  class Card class to represent playing cards.

```python
card = Card('3', '\u2660')
card.getRank()
# Output: '3'
card.getSuit()
# Output: '♠'
```

- The class Card should support methods:
  - Card(rank, suit): Constructor that initializes the rank and suit of the card
  - getRank(): Returns the card’s rank
  - getSuit(): Returns the card’s suit

- class Card:
- 'represents a playing card'
- def __init__(self, rank, suit):
- 'initialize rank and suit of card'
- self.rank = rank
- self.suit = suit
- def getRank(self):
- 'return rank'
- return self.rank
- def getSuit(self):
- 'return suit'
- return self.suit

---

<a id="slide-23"></a>

## Slide 23

Introduction to Computing Using Python

Container class: class Deck

Goal: develop a class Deck to represent a standard deck of 52 playing cards.

```python
deck = Deck()
deck.shuffle()
card = deck.dealCard()
card.getRank(), card.getSuit()
# Output: ('2', '♠')
card = deck.dealCard()
card.getRank(), card.getSuit()
# Output: ('Q', '♣')
card = deck.dealCard()
card.getRank(), card.getSuit()
# Output: ('4', '♢')
```

- The class Deck should support methods:
  - Deck(): Initializes the deck to contain a standard deck of 52 playing cards
  - shuffle(): Shuffles the deck
  - dealCard():  Pops and returns the card at the top of the deck

---

<a id="slide-24"></a>

## Slide 24

Introduction to Computing Using Python

Container class: class Deck

- class Deck:
- 'represents a deck of 52 cards'
- # ranks and suits are Deck class variables
- ranks = {'2','3','4','5','6','7','8','9','10','J','Q','K','A'}
- # suits is a set of 4 Unicode symbols representing the 4 suits
- suits = {'\u2660', '\u2661', '\u2662', '\u2663'}
- def __init__(self):
- 'initialize deck of 52 cards'
- self.deck = []          # deck is initially empty
- for suit in Deck.suits: # suits and ranks are Deck
- for rank in Deck.ranks: # class variables
- # add Card with given rank and suit to deck
- self.deck.append(Card(rank,suit))
- def dealCard(self):
- 'deal (pop and return) card from the top of the deck'
- return self.deck.pop()
- def shuffle(self):
- 'shuffle the deck'
- shuffle(self.deck)

---

<a id="slide-25"></a>

## Slide 25

Introduction to Computing Using Python

Container class: class Queue

Goal: develop a class Queue , an ordered collection of objects that restricts insertions to the rear of the queue and removal from the front of the queue

```python
appts = Queue()
appts.enqueue('John')
appts.enqueue('Annie')
appts.enqueue('Sandy')
appts.dequeue()
# Output: 'John'
appts.dequeue()
# Output: 'Annie'
appts.dequeue()
# Output: 'Sandy'
appts.isEmpty()
# Output: True
```

- The class Queue should support methods:
  - Queue(): Constructor that initializes the queue to an empty queue
  - enqueue(): Add item to the end of the queue
  - dequeue(): Remove and return the element at the front of the queue
  - isEmpty(): Returns True if the queue is empty, False otherwise

---

<a id="slide-26"></a>

## Slide 26

rear

rear

'Sandy'

'Annie'

Introduction to Computing Using Python

Container class: class Queue

```python
appts = Queue()
```

```python
appts = Queue()
appts.enqueue('John')
```

```python
appts = Queue()
appts.enqueue('John')
appts.enqueue('Annie')
```

```python
appts = Queue()
appts.enqueue('John')
appts.enqueue('Annie')
appts.enqueue('Sandy')
```

```python
appts = Queue()
appts.enqueue('John')
appts.enqueue('Annie')
appts.enqueue('Sandy')
appts.dequeue()
# Output: 'John'
```

```python
appts = Queue()
appts.enqueue('John')
appts.enqueue('Annie')
appts.enqueue('Sandy')
appts.dequeue()
# Output: 'John'
appts.dequeue()
# Output: 'Annie'
```

```python
appts = Queue()
appts.enqueue('John')
appts.enqueue('Annie')
appts.enqueue('Sandy')
appts.dequeue()
# Output: 'John'
appts.dequeue()
# Output: 'Annie'
appts.dequeue()
# Output: 'Sandy'
```

```python
appts = Queue()
appts.enqueue('John')
appts.enqueue('Annie')
appts.enqueue('Sandy')
appts.dequeue()
# Output: 'John'
appts.dequeue()
# Output: 'Annie'
appts.dequeue()
# Output: 'Sandy'
appts.isEmpty()
# Output: True
```

appts

'John'

front

rear

'Annie'

'Sandy'

rear

rear

---

<a id="slide-27"></a>

## Slide 27

Introduction to Computing Using Python

Container class: class Queue

- class Queue:
- 'a classic queue class'
- def __init__(self):
- 'instantiates an empty list'
- self.q = []
- def isEmpty(self):
- 'returns True if queue is empty, False otherwise'
- return (len(self.q) == 0)
- def enqueue (self, item):
- 'insert item at rear of queue'
- return self.q.append(item)
- def dequeue(self):
- 'remove and return item at front of queue'
- return self.q.pop(0)

---

<a id="slide-28"></a>

## Slide 28

Introduction to Computing Using Python

Our classes are not user-friendly

```python
deck = Deck()
deck.shuffle()
deck.dealCard()
# Output: <__main__.Card object at 0x10278ab90>
```

```python
a = Point(3, 4)
a
# Output: <__main__.Point object at 0x10278a690>
```

```python
appts = Queue()
len(appts)
# Output: Traceback (most recent call last):
```

- File "<pyshell#40>", line 1, in <module>
- len(appts)
- TypeError: object of type 'Queue' has no len()

```python
a = Point(3,4)
b = Point(1,2)
a+b
# Output: Traceback (most recent call last):
```

- File "<pyshell#44>", line 1, in <module>
- a+b
- TypeError: unsupported operand type(s) for +: 'Point' and 'Point'

```python
a = Point(3, 4)
a
# Output: Point(3, 4)
```

```python
a = Point(3,4)
b = Point(1,2)
a+b
# Output: Point(4, 6)
```

```python
appts = Queue()
len(appts)
# Output: 0
```

```python
deck = Deck()
deck.shuffle()
deck.dealCard()
# Output: Card('2', '♠’)
```

What would we prefer?

(x and y coordinates are added, respectively)

---

<a id="slide-29"></a>

## Slide 29

Introduction to Computing Using Python

Python operators

```python
'he' + 'llo'
# Output: 'hello'
[1,2] + [3,4]
# Output: [1, 2, 3, 4]
2+4
# Output: 6
```

```python
'he'.__add__('llo')
# Output: 'hello'
[1,2].__add__([3,4])
# Output: [1, 2, 3, 4]
int(2).__add__(4)
# Output: 6
```

- Operator + is defined for multiple classes; it is an overloaded operator.
  - For each class, the definition—and thus the meaning—of the operator is different.
    - integer addition for class int
    - list concatenation for class list
    - string concatenation for class str
  - How is the behavior of operator + defined for a particular class?

Class method __add__() implements the behavior of operator + for the class

object1 + object 2

object1.__add__(object2)

When Python evaluates

… it first translates it to method invocation …

- … and then evaluates
- the method invocation

---

<a id="slide-30"></a>

## Slide 30


| Operator | Method |
| --- | --- |
| x + y | x.__add__(y) |
| x – y | x.__sub__(y) |
| x * y | x.__mul__(y) |
| x / y | x.__truediv__(y) |
| x // y | x.__floordiv__(y) |
| x % y | x.__mod__(y) |
| x == y | x.__eq__(y) |
| x != y | x.__ne__(y) |
| x > y | x.__gt__(y) |
| x >= y | x.__ge__(y) |
| x < y | x.__lt__(y) |
| x <= y | x.__le__(y) |
| repr(x) | x.__repr__() |
| str(x) | x.__str__() |
| len(x) | x.__len__() |
| <type>(x) | <type>.__init__(x) |


Introduction to Computing Using Python

Python operators

In Python, all expressions involving operators are translated into method calls

    - (Recall that method invocations are then further translated to function calls in a namespace)

```python
'!'*10
# Output: '!!!!!!!!!!'
[1,2,3] == [2,3,4]
# Output: False
2 < 5
# Output: True
'a' <= 'a'
# Output: True
len([1,1,2,3,5,8])
# Output: 6
```

```python
repr([1,2,3])
# Output: '[1, 2, 3]'
repr(193)
# Output: '193'
repr(set())
# Output: 'set()'
```

Built-in function repr() returns the canonical string representation of an object

```python
[1,2,3]
# Output: [1, 2, 3]
193
# Output: 193
set()
# Output: set()
```

```python
[1,2,3].__repr__()
# Output: '[1, 2, 3]'
int(193).__repr__()
# Output: '193’
set().__repr__()
# Output: 'set()'
```

    - This is the representation printed by the shell when evaluating the object

- >> '!'.__mul__(10)
- '!!!!!!!!!!'
```python
[1,2,3].__eq__([2,3,4])
# Output: False
int(2).__lt__(5)
# Output: True
'a'.__le__('a')
# Output: True
[1,1,2,3,5,8].__len__()
# Output: 6
```

---

<a id="slide-31"></a>

## Slide 31

```python
a = Point(3, 4)
a
# Output: Point(3, 4)
```

Introduction to Computing Using Python

Overloading repr()

In Python, operators are translated into method calls

To add an overloaded operator to a user-defined class, the corresponding method must be implemented

```python
a = Point(3, 4)
a
# Output: Point(3, 4)
```

To get this behavior

method __repr__() must be implemented and added to class Point

- class Point:
- # other Point methods here
- def __repr__(self):
- 'canonical string representation Point(x, y)'
- return 'Point({}, {})'.format(self.x, self.y)

__repr__() should return the (canonical) string representation of the point

```python
a = Point(3, 4)
a.__repr__()
# Output: Point(3, 4)
```

```python
a = Point(3, 4)
a.__repr__()
# Output: Point(3, 4)
```

---

<a id="slide-32"></a>

## Slide 32

Introduction to Computing Using Python

Overloading operator +

To get this behavior

method __add__() must be implemented and added to class Point

- class Point:
- # other Point methods here
- def __add__(self, point):
- return Point(self.x+point.x, self.y+point.y)
- def __repr__(self):
- 'canonical string representation Point(x, y)'
- return 'Point({}, {})'.format(self.x, self.y)

```python
a = Point(3,4)
b = Point(1,2)
a+b
# Output: Point(4, 6)
```

__add__() should return a new Point object whose coordinates are the sum of the coordinates of a and b

```python
a = Point(3,4)
b = Point(1,2)
a.__add__(b)
# Output: Point(4, 6)
```

Also, method __repr__() should be implemented to achieve the desired display of the result in the shell

```python
a = Point(3,4)
b = Point(1,2)
a+b
# Output: Point(4, 6)
```

```python
a = Point(3,4)
b = Point(1,2)
a.__add__(b)
# Output: Point(4, 6)
```

---

<a id="slide-33"></a>

## Slide 33

Introduction to Computing Using Python

Overloading operator len()

To get this behavior

method __len__() must be implemented and added to class Queue

- __len__() should return the number of objects in the queue

```python
appts = Queue()
appts.__len__()
# Output: 0
```

```python
appts = Queue()
len(appts)
# Output: 0
```

- class Queue:
- def __init__(self):
- self.q = []
- def isEmpty(self):
- return (len(self.q) == 0)
- def enqueue (self, item):
- return self.q.append(item)
- def dequeue(self):
- return self.q.pop(0)

- __len__() should return the number of objects in the queue
  - i.e., the size of list self.q

- class Queue:
- def __init__(self):
- self.q = []
- def isEmpty(self):
- return (len(self.q) == 0)
- def enqueue (self, item):
- return self.q.append(item)
- def dequeue(self):
- return self.q.pop(0)
- def __len__(self):
- return len(self.q)

- We use the fact that len()
- is implemented for class list

---

<a id="slide-34"></a>

## Slide 34

Introduction to Computing Using Python

Exercise

Modify Deck and/or Card to get this behavior

```python
deck = Deck()
deck.shuffle()
deck.dealCard()
# Output: Card('2', '♠')
```

- class Deck:
- ranks = {'2','3','4','5','6','7','8','9','10','J','Q','K','A’}
- suits = {'\u2660', '\u2661', '\u2662', '\u2663’}
- def __init__(self):
- 'initialize deck of 52 cards'
- self.deck = []          # deck is initially empty
- for suit in Deck.suits: # suits and ranks are Deck
- for rank in Deck.ranks: # class variables
- self.deck.append(Card(rank,suit))
- def dealCard(self):
- return self.deck.pop()
- def shuffle(self):
- shuffle(self.deck)

- class Card:
- 'represents a playing card'
- def __init__(self, rank, suit):
- 'initialize rank and suit of card'
- self.rank = rank
- self.suit = suit
- def getRank(self):
- 'return rank'
- return self.rank
- def getSuit(self):
- 'return suit'
- return self.suit

- class Card:
- 'represents a playing card'
- def __init__(self, rank, suit):
- 'initialize rank and suit of card'
- self.rank = rank
- self.suit = suit
- def getRank(self):
- 'return rank'
- return self.rank
- def getSuit(self):
- 'return suit'
- return self.suit
- def __repr__(self):
- 'return formal representation'
- return "Card('{}', '{}')".format(self.rank, self.suit)

---

<a id="slide-35"></a>

## Slide 35

```python
print([1,2,3])
# Output: [1, 2, 3]
print(193)
# Output: 193
print(set())
# Output: set()
```

```python
[1,2,3].__str__()
# Output: '[1, 2, 3]'
int(193).__str__()
# Output: '193’
set().__str__()
# Output: 'set()'
```


| Operator | Method |
| --- | --- |
| x + y | x.__add__(y) |
| x – y | x.__sub__(y) |
| x * y | x.__mul__(y) |
| x / y | x.__truediv__(y) |
| x // y | x.__floordiv__(y) |
| x % y | x.__mod__(y) |
| x == y | x.__eq__(y) |
| x != y | x.__ne__(y) |
| x > y | x.__gt__(y) |
| x >= y | x.__ge__(y) |
| x < y | x.__lt__(y) |
| x <= y | x.__le__(y) |
| repr(x) | x.__repr__() |
| str(x) | x.__str__() |
| len(x) | x.__len__() |
| <type>(x) | <type>.__init__(x) |


Introduction to Computing Using Python

str() vs repr()

```python
str([1,2,3])
# Output: '[1, 2, 3]'
str(193)
# Output: '193'
str(set())
# Output: 'set()'
```

Built-in function str() returns the “pretty” string representation of an object

    - This is the representation printed by the print() statement and is meant to be readable by humans

Built-in function repr() returns the canonical string representation of an object

    - This is the representation printed by the shell when evaluating the object

---

<a id="slide-36"></a>

## Slide 36

```python
r = Representation()
r
# Output: canonical string representation
print(r)
# Output: Pretty string representation.
```

Introduction to Computing Using Python

str() vs repr()

Built-in function str() returns the “pretty” string representation of an object

    - This is the representation printed by the print() statement and is meant to be readable by humans

Built-in function repr() returns the canonical string representation of an object

    - This is the representation printed by the shell when evaluating the object

- class Representation(object):
- def __repr__(self):
- return 'canonical string representation'
- def __str__(self):
- return 'Pretty string representation.'

---

<a id="slide-37"></a>

## Slide 37

```python
repr([1,2,3])
# Output: '[1, 2, 3]'
[1,2,3]
# Output: [1, 2, 3]
```

```python
repr([1,2,3])
# Output: '[1, 2, 3]'
```

```python
repr([1,2,3])
# Output: '[1, 2, 3]'
[1,2,3]
# Output: [1, 2, 3]
eval(repr([1,2,3]))
# Output: [1, 2, 3]
```

```python
repr([1,2,3])
# Output: '[1, 2, 3]’
[1,2,3]
# Output: [1, 2, 3]
eval(repr([1,2,3]))
# Output: [1, 2, 3]
[1,2,3] == eval(repr([1,2,3]))
# Output: True
```

Introduction to Computing Using Python

Canonical string representation

Built-in function repr() returns the canonical string representation of an object

    - This is the representation printed by the shell when evaluating the object

    - Ideally, this is also the string used to construct the object
      - e.g., '[1, 2, 3]' , 'Point(3, 5)'

```python
repr(Point(3,5))
# Output: 'Point(3, 5)'
```

```python
repr(Point(3,5))
# Output: 'Point(3, 5)'
eval(repr(Point(3,5)))
# Output: Point(3, 5)
```

```python
repr(Point(3,5))
# Output: 'Point(3, 5)'
eval(repr(Point(3,5)))
# Output: Point(3, 5)
Point(3,5) == eval(repr(Point(3,5)))
# Output: False
```

Contract between the constructor and operator repr()

✗

Problem: operator ==

    - In other words, the expression
    - eval(repr(o))
    - should give back an object equal to the original object o

---

<a id="slide-38"></a>

## Slide 38

Introduction to Computing Using Python

Overloading operator ==

```python
a = Point(3,5)
b = Point(3,5)
a == b
# Output: False
```

```python
a = Point(3,5)
b = Point(3,5)
a == b
# Output: False
a == a
# Output: True
```

For user-defined classes, the default behavior for operator == is to return True only when the two objects are the same object.

- Usually, that is not the desired behavior
  - It also gets in the way of satisfying the contract between constructor and repr()

For class Point, operator == should return True if the two points have the same coordinates

- class Point:
- # other Point methods here
- def __eq__(self, other):
- 'self == other if they have the same coordinates'
- return self.x == other.x and self.y == other.y
- def __repr__(self):
- 'return canonical string representation Point(x, y)'
- return 'Point({}, {})'.format(self.x, self.y)`

- contract between constructor and
- repr() is now satisfied

---

<a id="slide-39"></a>

## Slide 39

Introduction to Computing Using Python

Exercise

We have already modified class Card to support function repr(). Now implement operator == so two cards with same rank and suit are equal.

```python
card1 = Card('4', '\u2662')
card2 = Card('4', '\u2662')
card1 == card2
# Output: True
```

- class Card:
- 'represents a playing card'
- def __init__(self, rank, suit):
- 'initialize rank and suit of card'
- self.rank = rank
- self.suit = suit
- def getRank(self):
- 'return rank'
- return self.rank
- def getSuit(self):
- 'return suit'
- return self.suit

- class Card:
- 'represents a playing card'
- def __init__(self, rank, suit):
- 'initialize rank and suit of card'
- self.rank = rank
- self.suit = suit
- def getRank(self):
- 'return rank'
- return self.rank
- def getSuit(self):
- 'return suit'
- return self.suit
- def __repr__(self):
- 'return formal representation'
- return "Card('{}', '{}')".format(self.rank, self.suit)

- class Card:
- 'represents a playing card'
- def __init__(self, rank, suit):
- 'initialize rank and suit of card'
- self.rank = rank
- self.suit = suit
- def getRank(self):
- 'return rank'
- return self.rank
- def getSuit(self):
- 'return suit'
- return self.suit
- def __repr__(self):
- 'return formal representation'
- return "Card('{}', '{}')".format(self.rank, self.suit)
- def __eq__(self, other):
- 'self == other if rank and suit are the same'
- return self.rank == other.rank and self.suit == other.suit

---

<a id="slide-40"></a>

## Slide 40

```python
mylst = MyList()
```

Introduction to Computing Using Python

Inheritance

- Code reuse is a key software engineering goal
  - One benefit of functions is they make it easier to reuse code
  - Similarly, organizing code into user-defined classes makes it easier to later reuse the code
    - E.g., classes Card and Deck can be
    - reused in  different card game apps

- A class can also be reused by extending
- it through inheritance

Example: Suppose that we find it convenient to have a class that behaves just like the built-in class list but also supports a method called choice() that returns an item from the list, chosen uniformly at random.

```python
mylst = MyList()
mylst.append(2)
mylst.append(3)
mylst.append(5)
mylst.append(7)
len(mylst)
# Output: 4
mylst.index(5)
# Output: 2
```

```python
mylst = MyList()
mylst.append(2)
mylst.append(3)
mylst.append(5)
mylst.append(7)
len(mylst)
# Output: 4
mylst.index(5)
# Output: 2
mylst.choice()
# Output: 7
```

```python
mylst = MyList()
mylst.append(2)
mylst.append(3)
mylst.append(5)
mylst.append(7)
len(mylst)
# Output: 4
mylst.index(5)
# Output: 2
mylst.choice()
# Output: 7
mylst.choice()
# Output: 3
mylst.choice()
# Output: 3
mylst.choice()
# Output: 5
mylst.choice()
# Output: 3
```

A MyList object should behave just like a list

A MyList object should also support method choice()

```python
mylst = MyList()
mylst.append(2)
mylst.append(3)
mylst.append(5)
mylst.append(7)
len(mylst)
# Output: 4
mylst.index(5)
# Output: 2
mylst.choice()
# Output: 7
mylst.choice()
# Output: 3
```

---

<a id="slide-41"></a>

## Slide 41

Introduction to Computing Using Python

Implementing class MyList

- Approach 1: Develop class MyList from scratch
  - Just like classes Deck and Queue

- import random
- class MyList:
- def __init__(self, initial = []):
- self.lst = initial
- def __len__(self):
- return len(self.lst)
- def append(self, item):
- self.lst.append(self, item)
- # implementations of remaining "list" methods
- def choice(self):
- return random.choice(self.lst)

Approach 2: Develop class MyList by inheritance from class list

Huge amount of work!

- import random
- class MyList(list):
- 'a subclass of list that implements method choice'
- def choice(self):
- 'return item from list chosen uniformly at random'
- return random.choice(self)

---

<a id="slide-42"></a>

## Slide 42

Introduction to Computing Using Python

Implementing class MyList

Example: Suppose that we find it convenient to have a class that behaves just like the built-in class list but also supports a method called choice() that returns an item from the list, chosen uniformly at random.

```python
mylst = MyList()
mylst.append(2)
mylst.append(3)
mylst.append(5)
mylst.append(7)
len(mylst)
# Output: 4
mylst.index(5)
# Output: 2
mylst.choice()
# Output: 7
mylst.choice()
# Output: 3
mylst.choice()
# Output: 3
mylst.choice()
# Output: 5
mylst.choice()
# Output: 3
```

A MyList object should behave just like a list

A MyList object should also support method choice()

- Approach 1: Develop class MyList from scratch
  - Just like classes Deck and Queue

Approach 2: Develop class MyList by inheritance from class list

Huge amount of work!

Class MyList inherits all the attributes of class list

---

<a id="slide-43"></a>

## Slide 43

Introduction to Computing Using Python

Class MyList by inheritance

- import random
- class MyList(list):
- 'a subclass of list that implements method choice'
- def choice(self):
- 'return item from list chosen uniformly at random'
- return random.choice(self)

choice

class MyList

[2,3,5,7]

__init__

class list

append

index

__len__

. . .

```python
dir(MyList)
# Output: ['__add__', '__class__',
```

- . . .
- 'choice', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

Class MyList inherits all the attributes of class list

```python
dir(MyList)
# Output: ['__add__', '__class__',
```

- . . .
- 'choice', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
```python
dir(mylst)
# Output: ['__add__', '__class__',
```

- . . .
- 'choice', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

Object mylst inherits all the attributes of class MyList (which inherits all the attributes of class list)

object mylst

---

<a id="slide-44"></a>

## Slide 44

Introduction to Computing Using Python

Class definition, in general

class <Class Name>:

class <Class Name>(<Super Class>):

class <Class Name>(<Super Class 1>, <Super Class 2>, …):

A class can be defined “from scratch” using:

A class can also be derived from another class, through inheritance

A class can also inherit attributes from more than one superclass

class <Class Name>:

is a shorthand for

class <Class Name>(object):

object is a built-in class with no attributes; it is the class that all classes inherit from, directly or indirectly

```python
help(object)
# Output: Help on class object in module builtins:
```

- class object
- |  The most base type

---

<a id="slide-45"></a>

## Slide 45

- class Animal:
- 'represents an animal’
- def setSpecies(self, species):
- 'sets the animal species'
- self.spec = species
- def setLanguage(self, language):
- 'sets the animal language'
- self.lang = language
- def speak(self):
- 'prints a sentence by the animal'
- print('I am a {} and I {}.'.format(self.spec, self.lang))

Introduction to Computing Using Python

Overriding superclass methods

Sometimes we need to develop a new class that can almost inherit attributes from an existing class… but not quite.

```python
snoopy = Animal()
snoopy.setSpecies('dog')
snoopy.setLanguage('bark')
snoopy.speak()
# Output: I am a dog and I bark.
```

```python
snoopy = Animal()
snoopy.setSpecies('dog')
snoopy.setLanguage('bark')
snoopy.speak()
# Output: I am a dog and I bark.
tweety = Bird()
tweety.setSpecies('canary')
tweety.setLanguage('tweet')
tweety.speak()
# Output: tweet! tweet! tweet!
```

For example, a class Bird that supports the same methods class Animal supports (setSpecies(), setLanguage(), and speak()) but with a different behavior for method speak()

---

<a id="slide-46"></a>

## Slide 46

- class Bird(Animal):
- 'represents a bird'
- def speak(self):
- 'prints bird sounds'
- print('{}! '.format(self.lang) * 3)

Introduction to Computing Using Python

Overriding superclass methods

```python
snoopy = Animal()
snoopy.setSpecies('dog')
snoopy.setLanguage('bark')
snoopy.speak()
# Output: I am a dog and I bark.
```

```python
snoopy = Animal()
snoopy.setSpecies('dog')
snoopy.setLanguage('bark')
snoopy.speak()
# Output: I am a dog and I bark.
tweety = Bird()
tweety.setSpecies('canary')
tweety.setLanguage('tweet')
tweety.speak()
# Output: tweet! tweet! tweet!
```

setLanguage

speak

class Bird

setSpecies

class Animal

speak

object tweety

lang

spec

object snoopy

lang

spec

Bird inherits all the attributes of Animal…

… but then overrides the behavior of method speak()

method speak() defined in Animal is used

method speak() defined in Bird is used

Python looks for the definition of an attribute by starting with the name- space associated with object and continuing up the class hierarchy.

---

<a id="slide-47"></a>

## Slide 47

Introduction to Computing Using Python

Extending superclass methods

- class Super:
- 'a generic class with one method'
- def method(self):                     # the Super method
- print('in Super.method')
- class Inheritor(Super):
- 'class that inherits method'
- pass
- class Replacer(Super):
- 'class that overrides method'
- def method(self):
- print('in Replacer.method')
- class Extender(Super):
- 'class that extends method'
- def method(self):
- print('starting Extender.method')
- Super.method(self)                # calling Super method
- print('ending Extender.method')

A superclass method can be inherited as-is, overridden, or extended.

---

<a id="slide-48"></a>

## Slide 48

Introduction to Computing Using Python

Object-Oriented Programming (OOP)

Code reuse is a key benefit of organizing code into new classes; it is made possible through abstraction and encapsulation.

  - Abstraction: The idea that a class object can be manipulated by users through method invocations alone and without knowledge of the implementation of these methods.
    - Abstraction facilitates software development because the programmer works with objects abstractly (i.e., through “abstract”, meaningful method names rather than “concrete”, technical code).

  - Encapsulation: In order for abstraction to be beneficial, the “concrete” code and data associated with objects must be encapsulated (i.e., made “invisible” to the program using the object).
    - Encapsulation is achieved thanks to the fact that (1) every class defines a namespace in which class attributes live, and (2) every object has a namespace, that inherits the class attributes, in which instance attributes live.

OOP is an approach to programming that achieves modular code through the use of objects and by structuring code into user-defined classes.

---

<a id="slide-49"></a>

## Slide 49

Introduction to Computing Using Python

An encapsulation issue

- The current implementation of class Queue does not completely encapsulate
- its implementation

```python
queue = Queue()
queue.dequeue()
# Output: Traceback (most recent call last):
```

- File "<pyshell#48>", line 1, in <module>
- queue.dequeue()
- File "/Users/me/ch8.py", line 93, in dequeue
- return self.q.pop(0)
- IndexError: pop from empty list

What is the problem?

The user of class Queue should not have to know the implementation detail that a list stores the items in a Queue object

```python
queue = Queue()
queue.dequeue()
# Output: Traceback (most recent call last):
```

- File "<pyshell#76>", line 1, in <module>
- queue.dequeue()
- File "/Users/me/ch8.py", line 120, in dequeue
- raise EmptyQueueError('dequeue from empty queue')
- EmptyQueueError: dequeue from empty queue

What should be output instead?

We need to be able to define user-defined exceptions

But first, we need to learn how to “force” an exception to be raised

---

<a id="slide-50"></a>

## Slide 50

Introduction to Computing Using Python

Raising an exception

By typing Ctrl-C, a user can force a KeyboardInterrupt exception to be raised

```python
while True:
# Output: pass
```

```python
while True:
# Output: pass
# Output: Traceback (most recent call last):
```

- File "<pyshell#53>", line 2, in <module>
- pass
- KeyboardInterrupt

```python
while True:
# Output: pass
# Output: Traceback (most recent call last):
```

- File "<pyshell#53>", line 2, in <module>
- pass
- KeyboardInterrupt
```python
raise ValueError()
# Output: Traceback (most recent call last):
```

- File "<pyshell#54>", line 1, in <module>
- raise ValueError()
- ValueError

```python
while True:
# Output: pass
# Output: Traceback (most recent call last):
```

- File "<pyshell#53>", line 2, in <module>
- pass
- KeyboardInterrupt
```python
raise ValueError()
# Output: Traceback (most recent call last):
```

- File "<pyshell#54>", line 1, in <module>
- raise ValueError()
- ValueError
```python
raise ValueError('Just joking...')
# Output: Traceback (most recent call last):
```

- File "<pyshell#55>", line 1, in <module>
- raise ValueError('Just joking...')
- ValueError: Just joking...

```python
while True:
# Output: pass
# Output: Traceback (most recent call last):
```

- File "<pyshell#53>", line 2, in <module>
- pass
- KeyboardInterrupt
```python
raise ValueError()
# Output: Traceback (most recent call last):
```

- File "<pyshell#54>", line 1, in <module>
- raise ValueError()
- ValueError
```python
raise ValueError('Just joking...')
# Output: Traceback (most recent call last):
```

- File "<pyshell#55>", line 1, in <module>
- raise ValueError('Just joking...')
- ValueError: Just joking...
```python
try:
# Output: raise ValueError()
```

- except:
- print('Caught exception.')
- Caught exception.

- Any exception can be raised
- within a program with the
- raise statement

  - ValueError, like all exception types, is a class
  - ValueError() uses the default constructor to create an exception (object)
  - statement raise switches control flow from normal to exceptional

  - The constructor can take a “message” argument to be stored in the exception object

---

<a id="slide-51"></a>

## Slide 51

Introduction to Computing Using Python

User-defined exceptions

Every built-in exception type is a subclass of class Exception.

```python
class MyError(Exception):
# Output: pass
```

```python
class MyError(Exception):
# Output: pass
raise MyError('Message in a bottle')
# Output: Traceback (most recent call last):
```

- File "<pyshell#71>", line 1, in <module>
- raise MyError('Message in a bottle')
- MyError: Message in a bottle

A new exception class should be a subclass, either directly or indirectly, of Exception.

```python
help(Exception)
# Output: Help on class Exception in module builtins:
```

- class Exception(BaseException)
- |  Common base class for all non-exit exceptions.
- |
- |  Method resolution order:
- |      Exception
- |      BaseException
- |      object
- . . .

---

<a id="slide-52"></a>

## Slide 52

Introduction to Computing Using Python

Class Queue, revisited

Our goal was to encapsulate class Queue better:

```python
queue = Queue()
queue.dequeue()
# Output: Traceback (most recent call last):
```

- File "<pyshell#76>", line 1, in <module>
- queue.dequeue()
- File "/Users/me/ch8.py", line 120, in dequeue
- raise EmptyQueueError('dequeue from empty queue')
- EmptyQueueError: dequeue from empty queue

- To achieve this behavior, we:
  - Need to create exception class EmptyQueueError
  - Modify Queue method dequeue so an EmptyQueueError exception is raised if an attempt to dequeue an empty queue is made

---

<a id="slide-53"></a>

## Slide 53

- class EmptyQueueError(Exception):
- pass
- class Queue:
- 'a classic queue class'
- def __init__(self):
- 'instantiates an empty list'
- self.q = []
- def isEmpty(self):
- 'returns True if queue is empty, False otherwise'
- return (len(self.q) == 0)
- def enqueue (self, item):
- 'insert item at rear of queue'
- return self.q.append(item)
- def dequeue(self):
- 'remove and return item at front of queue'
- if self.isEmpty():
- raise EmptyQueueError('dequeue from empty queue')
- return self.q.pop(0)

Introduction to Computing Using Python

Class Queue, revisited